  <script>
    /* ---------- State ---------- */
    let installedFonts = [];
    let loadedFontFiles = {};
    let loadedOpentypeFonts = {};
    let currentFormat = 'svg';
    let currentCharCode = null;
    let currentFont = null;

    // Colors
    let symbolColor = '#000000';
    let bgColor = '#ffffff';
    let colorTarget = 'symbol';

    // Background render options
    let bgEnabled = true;
    let bgShape = 'circle';
    let bgSizeUnit = '%';
    let bgSizeValue = 60;
    let bgBorderEnabled = false;
    let bgBorderColor = '#1a202c';
    let bgBorderWidth = 4;

    // Independent offsets
    let bgOffsetX = 0, bgOffsetY = 0;
    let symbolOffsetX = 0, symbolOffsetY = 0;
    const dpadStep = 5;

    // DOM refs
    const fontSearch = document.getElementById('fontSearch');
    const fontDropdown = document.getElementById('fontDropdown');
    const fontSelect = document.getElementById('fontSelect');
    const clearFontBtn = document.getElementById('clearFontBtn');
    const fontFileInput = document.getElementById('fontFileInput');
    const colorInput = document.getElementById('colorInput');
    const colorTargetSymbolBtn = document.getElementById('colorTargetSymbol');
    const colorTargetBgBtn = document.getElementById('colorTargetBackground');
    const colorTargetBorderBtn = document.getElementById('colorTargetBorder');
    const previewHost = document.getElementById('previewCanvasHost');
    const previewHint = document.getElementById('previewHint');
    const bgShapeCircleBtn = document.getElementById('bgShapeCircle');
    const bgShapeSquareBtn = document.getElementById('bgShapeSquare');
    const bgSizeSlider = document.getElementById('bgSizeSlider');
    const unitPercentBtn = document.getElementById('unitPercent');
    const unitPixelsBtn = document.getElementById('unitPixels');
    const bgSizeLabel = document.getElementById('bgSizeLabel');
    const offsetReadout = document.getElementById('offsetReadout');
    const symOffsetReadout = document.getElementById('symOffsetReadout');
    const downloadBtn = document.getElementById('downloadBtn');
    const bgBorderToggleBtn = document.getElementById('bgBorderToggle');
    const borderControls = document.getElementById('borderControls');
    const borderWidthInput = document.getElementById('borderWidthInput');
    function setColorTarget(target){
      if(target==='background' && !bgEnabled){ target = 'symbol'; }
      if(target==='border' && (!bgEnabled || !bgBorderEnabled)){ target = bgEnabled ? 'background' : 'symbol'; }
      colorTarget = target;
      colorTargetSymbolBtn.classList.toggle('active', target==='symbol');
      colorTargetBgBtn.classList.toggle('active', target==='background');
      colorTargetBorderBtn.classList.toggle('active', target==='border');
      if(target==='symbol'){ colorInput.value = symbolColor; }
      else if(target==='background'){ colorInput.value = bgColor; }
      else if(target==='border'){ colorInput.value = bgBorderColor; }
      syncColorTargetButtons();
    }

    function syncColorTargetButtons(){
      colorTargetBgBtn.disabled = !bgEnabled;
      colorTargetBorderBtn.disabled = !(bgEnabled && bgBorderEnabled);
    }

    function ensureValidColorTarget(){
      if(colorTarget==='background' && !bgEnabled){
        setColorTarget('symbol');
      } else if(colorTarget==='border' && (!bgEnabled || !bgBorderEnabled)){
        setColorTarget(bgEnabled ? 'background' : 'symbol');
      }
    }

    function syncBorderUI(){
      const borderActive = bgEnabled && bgBorderEnabled;
      bgBorderToggleBtn.classList.toggle('active', borderActive);
      bgBorderToggleBtn.disabled = !bgEnabled;
      bgBorderToggleBtn.setAttribute('aria-pressed', borderActive);
      borderControls.style.display = borderActive ? 'flex' : 'none';
      borderWidthInput.disabled = !borderActive;
      borderWidthInput.value = bgBorderWidth;
      syncColorTargetButtons();
      ensureValidColorTarget();
    }

    function setBorderEnabled(enabled){
      bgBorderEnabled = enabled && bgEnabled;
      syncBorderUI();
      if(bgBorderEnabled){
        setColorTarget('border');
      }
      renderPreview();
    }

    function syncBackgroundUI(){
      bgShapeCircleBtn.classList.toggle('active', bgEnabled && bgShape==='circle');
      bgShapeSquareBtn.classList.toggle('active', bgEnabled && bgShape==='square');
      bgShapeCircleBtn.setAttribute('aria-pressed', bgEnabled && bgShape==='circle');
      bgShapeSquareBtn.setAttribute('aria-pressed', bgEnabled && bgShape==='square');
      syncBorderUI();
    }

    function toggleBackgroundShape(shape){
      if(bgShape === shape && bgEnabled){
        bgEnabled = false;
      } else {
        bgShape = shape;
        bgEnabled = true;
      }
      if(!bgEnabled && bgBorderEnabled){
        bgBorderEnabled = false;
      }
      syncBackgroundUI();
      ensureValidColorTarget();
      renderPreview();
    }

    /* ---------- Loader banner ---------- */
    function reconstructLoadingBanner(totalFontCount=0){
      const loadingBanner = document.getElementById('loadingBanner');
      const statusMessage = totalFontCount>0 ? `✓ ${totalFontCount} ArcGIS Fonts loaded and ready to use.` : '';
      loadingBanner.innerHTML = `
        <div class="header-button-row">
          <button class="load-font-btn" onclick="loadArcGISFonts()">Load ArcGIS Fonts</button>
          <button class="copy-path-btn" onclick="copyFontPath()"><span class="copy-path-btn-text">Copy ArcGIS Font path if needed</span></button>
        </div>
        <div id="loadStatus" class="load-status-bar">${statusMessage}</div>
      `;
    }

    function copyFontPath(){
      // Windows Explorer–friendly path
      const path = 'C:\\Program Files\\ArcGIS\\Pro\\Resources\\Fonts';
      const btn = event.target.closest('.copy-path-btn');
      navigator.clipboard.writeText(path).then(()=>{
        const span = btn.querySelector('.copy-path-btn-text');
        const original = 'Copy ArcGIS Font path if needed';
        span.textContent = 'Path Copied!';
        btn.classList.add('copied');
        btn.classList.remove('glowing'); void btn.offsetWidth; btn.classList.add('glowing');
        setTimeout(()=>{ span.textContent = original; btn.classList.remove('copied') },2000);
        setTimeout(()=>{ btn.classList.remove('glowing') },800);
      }).catch(()=>{
        const span = btn.querySelector('.copy-path-btn-text');
        const original = 'Copy ArcGIS Font path if needed';
        span.textContent = 'Failed!'; btn.style.backgroundColor = '#e53e3e';
        setTimeout(()=>{ span.textContent = original; btn.style.backgroundColor='' },2000);
      });
    }

    /* ---------- Font selection ---------- */
    function populateFontDropdown(filterText=''){
      const filtered = installedFonts.filter(f=>f.toLowerCase().includes(filterText.toLowerCase()));
      if (filtered.length===0){
        fontDropdown.innerHTML = '<div class="no-results">No fonts loaded. Please load font files.</div>';
      } else {
        fontDropdown.innerHTML = filtered.map(font=>`<div class="font-option" data-font="${font}">${font}</div>`).join('');
        document.querySelectorAll('.font-option').forEach(el=>{
          el.addEventListener('click',()=>selectFont(el.dataset.font));
        });
      }
    }

    function selectFont(fontName){
      fontSearch.value = fontName;
      fontSelect.value = fontName;
      currentFont = fontName;
      fontDropdown.style.display = 'none';
      clearFontBtn.style.display = 'block';
      renderPreview();
      updateDownloadAvailability();
    }

    function clearFontSelection(){
      fontSearch.value=''; fontSelect.value=''; currentFont=null;
      clearFontBtn.style.display='none'; populateFontDropdown(''); fontDropdown.style.display='block'; fontSearch.focus();
      updateDownloadAvailability();
    }

    fontSearch.addEventListener('focus', function(){ populateFontDropdown(this.value); fontDropdown.style.display='block';});
    fontSearch.addEventListener('input', function(){ populateFontDropdown(this.value); fontDropdown.style.display='block'; if (this.value && fontSelect.value){ clearFontBtn.style.display='block';}});
    document.addEventListener('click', e=>{ if(!e.target.closest('.input-group')) fontDropdown.style.display='none'; });

    /* ---------- Format toggle ---------- */
    document.querySelectorAll('.toggle-btn[data-format]').forEach(btn=>{
      btn.addEventListener('click', function(){
        document.querySelectorAll('.toggle-btn[data-format]').forEach(b=>b.classList.remove('active'));
        this.classList.add('active');
        currentFormat = this.dataset.format;
        const svgInput = document.getElementById('svgSizeInput');
        const pngInput = document.getElementById('sizeInput');
        const sizeLabel = document.getElementById('sizeLabel');
        if (currentFormat==='png'){ pngInput.style.display='block'; svgInput.style.display='none'; sizeLabel.textContent='PNG Size (pixels)'; }
        else { pngInput.style.display='none'; svgInput.style.display='block'; sizeLabel.textContent='SVG Size (pixels)'; }
      });
    });

    /* ---------- Inputs & Keyboard ---------- */
    const keyInput = document.getElementById('keyInput');
    const decimalInput = document.getElementById('decimalInput');
    const hexInput = document.getElementById('hexInput');
    const keyboard = document.getElementById('onscreenKeyboard');
    let isShifted = false;

    function updateDownloadAvailability(){
      const decimalValue = parseInt(decimalInput.value,10);
      if(Number.isFinite(decimalValue)){
        currentCharCode = decimalValue;
      } else {
        currentCharCode = null;
      }
      downloadBtn.disabled = !(currentFont && Number.isFinite(decimalValue));
    }

    // Sync three inputs both ways
    keyInput.addEventListener('input', ()=>{
      const v = keyInput.value;
      if(!v){
        decimalInput.value='';
        hexInput.value='';
        renderPreview();
        updateDownloadAvailability();
        return;
      }
      let code;
      if (v.toLowerCase()==='space') code = 32;
      else if (v.toUpperCase().startsWith('U+') && v.length>2) code = parseInt(v.substring(2),16);
      else code = v.codePointAt(0);
      if(Number.isFinite(code)){
        decimalInput.value = code;
        hexInput.value = code.toString(16).toUpperCase().padStart(4,'0');
      }
      renderPreview();
      updateDownloadAvailability();
    });
    decimalInput.addEventListener('input', ()=>{
      const d = parseInt(decimalInput.value,10);
      if(Number.isFinite(d)){
        keyInput.value = (d===32) ? 'Space' : String.fromCodePoint(d);
        hexInput.value = d.toString(16).toUpperCase().padStart(4,'0');
      } else { hexInput.value=''; keyInput.value=''; }
      renderPreview();
      updateDownloadAvailability();
    });
    hexInput.addEventListener('input', ()=>{
      const h = parseInt(hexInput.value,16);
      if(Number.isFinite(h)){
        decimalInput.value = h;
        keyInput.value = (h===32) ? 'Space' : String.fromCodePoint(h);
      } else { decimalInput.value=''; keyInput.value=''; }
      renderPreview();
      updateDownloadAvailability();
    });

    function updateKeyboardLabels(){
      keyboard.querySelectorAll('.key-btn').forEach(btn=>{
        const main = btn.getAttribute('data-main');
        const sh = btn.getAttribute('data-shift');
        if(main){ btn.textContent = isShifted ? (sh || main) : main; }
        else {
          const ch = btn.getAttribute('data-char');
          if(ch==='backspace') btn.textContent = '⌫ Backspace';
          if(ch==='tab') btn.textContent = 'Tab';
          if(ch==='enter') btn.textContent = 'Enter ⏎';
          if(ch==='Shift') btn.textContent = '⇧ Shift';
          if(ch==='ctrl') btn.textContent = 'Ctrl';
          if(ch==='alt') btn.textContent = 'Alt';
          if(ch==='Space') btn.textContent = 'Space';
        }
      });
    }

    if (keyboard){
      keyboard.addEventListener('click', function(e){
        const btn = e.target.closest('.key-btn'); if(!btn) return;
        const charType = btn.dataset.char;
        if(charType==='Shift'){
          isShifted=!isShifted;
          document.querySelectorAll('.key-btn[data-char="Shift"]').forEach(s=>s.classList.toggle('active',isShifted));
          updateKeyboardLabels();
          return;
        }
        if(charType==='backspace'){ keyInput.value=''; keyInput.dispatchEvent(new Event('input')); return; }
        if(charType==='Space'){ keyInput.value='Space'; keyInput.dispatchEvent(new Event('input')); if(isShifted){ isShifted=false; document.querySelectorAll('.key-btn[data-char="Shift"]').forEach(s=>s.classList.remove('active')); updateKeyboardLabels(); } return; }

        const main = btn.getAttribute('data-main');
        const sh = btn.getAttribute('data-shift');
        if(main){
          let ch = isShifted ? (sh || main) : main;
          if(ch.length===1 && /[a-z]/i.test(main)){
            ch = isShifted ? ch.toUpperCase() : ch.toLowerCase();
          }
          keyInput.value = ch;
          keyInput.dispatchEvent(new Event('input'));
          if(isShifted){
            isShifted=false;
            document.querySelectorAll('.key-btn[data-char="Shift"]').forEach(s=>s.classList.remove('active'));
            updateKeyboardLabels();
          }
        }
      });
    }
    document.getElementById('oskLabel')?.addEventListener('click', ()=>{
      document.getElementById('onscreenKeyboardContainer').classList.toggle('expanded');
    });

    /* ---------- Preview Rendering (SVG in host) ---------- */
    function escapeXml(s){ return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

    function computeLayout(width, height){
      const topPad = Math.round(height * 0.08);
      const availableHeight = Math.max(1, height - topPad);
      const baseSpan = Math.max(1, Math.min(width, availableHeight));
      const centreX = Math.round(width / 2);
      const centreLine = Math.round(topPad + baseSpan * 0.25);
      const bgSizePx = (bgSizeUnit === '%')
        ? Math.max(8, Math.round(baseSpan * (bgSizeValue / 100)))
        : Math.max(8, Math.round(bgSizeValue));
      const symbolFontSize = Math.round(baseSpan * 0.35);

      return {
        width,
        height,
        centreX,
        centreY: centreLine,
        crosshair: `
          <line x1="0" y1="${Math.round(height/2)}" x2="${width}" y2="${Math.round(height/2)}" stroke="#a0aec0" stroke-width="1" stroke-dasharray="4 4" opacity="0.6"/>
          <line x1="${centreX}" y1="0" x2="${centreX}" y2="${height}" stroke="#a0aec0" stroke-width="1" stroke-dasharray="4 4" opacity="0.6"/>
        `,
        background: {
          cx: centreX + bgOffsetX,
          cy: centreLine + bgOffsetY,
          size: bgSizePx
        },
        symbol: {
          cx: centreX + symbolOffsetX,
          cy: centreLine + symbolOffsetY,
          fontSize: symbolFontSize
        }
      };
    }

    function buildBackgroundMarkup(layout){
      if(!bgEnabled){ return ''; }
      const { cx, cy, size } = layout.background;
      const strokeLineJoin = (bgBorderEnabled && bgShape === 'square') ? ' stroke-linejoin="round"' : '';
      const strokeAttrs = bgBorderEnabled
        ? ` stroke="${bgBorderColor}" stroke-width="${bgBorderWidth}"${strokeLineJoin}`
        : ' stroke="none"';
      if(bgShape === 'circle'){
        return `<circle cx="${cx}" cy="${cy}" r="${Math.round(size/2)}" fill="${bgColor}"${strokeAttrs}/>`;
      }
      if(bgShape === 'square'){
        const half = Math.round(size / 2);
        return `<rect x="${Math.round(cx - half)}" y="${Math.round(cy - half)}" width="${size}" height="${size}" rx="${Math.round(size*0.1)}" fill="${bgColor}"${strokeAttrs}/>`;
      }
      return '';
    }

    function buildGlyphMarkup(font, charVal, symbolLayout){
      try{
        const glyph = font.charToGlyph(charVal);
        if(!glyph || glyph.index === 0){ return null; }
        const basePath = glyph.getPath(0, 0, symbolLayout.fontSize);
        const pathData = basePath.toPathData(3);
        const bounds = basePath.getBoundingBox();
        const centerX = (bounds.x1 + bounds.x2) / 2;
        const centerY = (bounds.y1 + bounds.y2) / 2;
        const translateToCenter = `translate(${(-centerX).toFixed(2)}, ${(-centerY).toFixed(2)})`;
        const translateToTarget = `translate(${symbolLayout.cx.toFixed(2)}, ${symbolLayout.cy.toFixed(2)})`;
        return `
          <g transform="${translateToTarget} scale(1,-1) ${translateToCenter}">
            <path d="${pathData}" fill="${symbolColor}"/>
          </g>
        `;
      }catch(err){
        console.error('Failed to convert glyph to path', err);
        return null;
      }
    }

    function buildSymbolMarkup(layout, { useGlyph } = {}){
      const code = parseInt(decimalInput.value, 10);
      if(!Number.isFinite(code)){ return null; }
      const charVal = String.fromCodePoint(code);
      let glyphMarkup = null;
      if(useGlyph && loadedOpentypeFonts[currentFont]){
        glyphMarkup = buildGlyphMarkup(loadedOpentypeFonts[currentFont], charVal, layout.symbol);
      }
      if(glyphMarkup){
        return glyphMarkup;
      }
      return `
        <text x="${layout.symbol.cx}" y="${layout.symbol.cy}" fill="${symbolColor}"
              font-family="${currentFont}, sans-serif"
              font-size="${layout.symbol.fontSize}"
              text-anchor="middle" dominant-baseline="central">${escapeXml(charVal)}</text>
      `;
    }

    function composeSymbolSVG(width, height, { includeCrosshair = false, useGlyph = false } = {}){
      if(!currentFont){ return null; }
      const layout = computeLayout(width, height);
      const symbolMarkup = buildSymbolMarkup(layout, { useGlyph });
      if(!symbolMarkup){
        return null;
      }
      const bgMarkup = buildBackgroundMarkup(layout);
      const crosshairMarkup = includeCrosshair ? layout.crosshair : '';
      return `
        <svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg">
          ${crosshairMarkup}
          ${bgMarkup}
          ${symbolMarkup}
        </svg>
      `.trim();
    }

    function renderPreview(){
      const width = previewHost.clientWidth || 520;
      const height = previewHost.clientHeight || 288;
      const svgMarkup = composeSymbolSVG(width, height, { includeCrosshair: true, useGlyph: false });
      if(!svgMarkup){
        previewHost.innerHTML = '';
        previewHint.style.display = 'block';
      } else {
        previewHint.style.display = 'none';
        previewHost.innerHTML = svgMarkup;
      }
    }

    /* ---------- D-pads & Centre buttons ---------- */
    document.getElementById('dpadUp').addEventListener('click', ()=>{ bgOffsetY -= dpadStep; updateOffsetsUI(); renderPreview(); });
    document.getElementById('dpadDown').addEventListener('click', ()=>{ bgOffsetY += dpadStep; updateOffsetsUI(); renderPreview(); });
    document.getElementById('dpadLeft').addEventListener('click', ()=>{ bgOffsetX -= dpadStep; updateOffsetsUI(); renderPreview(); });
    document.getElementById('dpadRight').addEventListener('click', ()=>{ bgOffsetX += dpadStep; updateOffsetsUI(); renderPreview(); });
    document.getElementById('dpadCenter').addEventListener('click', ()=>{ bgOffsetX=0; bgOffsetY=0; updateOffsetsUI(); renderPreview(); });

    document.getElementById('symDpadUp').addEventListener('click', ()=>{ symbolOffsetY -= dpadStep; updateOffsetsUI(); renderPreview(); });
    document.getElementById('symDpadDown').addEventListener('click', ()=>{ symbolOffsetY += dpadStep; updateOffsetsUI(); renderPreview(); });
    document.getElementById('symDpadLeft').addEventListener('click', ()=>{ symbolOffsetX -= dpadStep; updateOffsetsUI(); renderPreview(); });
    document.getElementById('symDpadRight').addEventListener('click', ()=>{ symbolOffsetX += dpadStep; updateOffsetsUI(); renderPreview(); });
    document.getElementById('symDpadCenter').addEventListener('click', ()=>{ symbolOffsetX=0; symbolOffsetY=0; updateOffsetsUI(); renderPreview(); });

    function getCanvasMetrics() {
      const hostW = previewHost.clientWidth || 520;
      const hostH = previewHost.clientHeight || 288;
      const layout = computeLayout(hostW, hostH);
      return {
        hostW,
        hostH,
        trueCx: layout.centreX,
        targetCyLine: layout.centreY
      };
    }

    document.getElementById('dpadCenterToCanvas')?.addEventListener('click', () => {
      const { targetCyLine } = getCanvasMetrics();
      const trueCy = Math.round((previewHost.clientHeight || 288) / 2);
      bgOffsetX = 0;
      bgOffsetY = trueCy - targetCyLine;
      updateOffsetsUI();
      renderPreview();
    });

    document.getElementById('symCenterToCanvas')?.addEventListener('click', () => {
      const { targetCyLine } = getCanvasMetrics();
      const trueCy = Math.round((previewHost.clientHeight || 288) / 2);
      symbolOffsetX = 0;
      symbolOffsetY = trueCy - targetCyLine;
      updateOffsetsUI();
      renderPreview();
    });

    function updateOffsetsUI(){
      offsetReadout.textContent = `${bgOffsetX}, ${bgOffsetY}`;
      symOffsetReadout.textContent = `${symbolOffsetX}, ${symbolOffsetY}`;
    }

    /* ---------- Downloads ---------- */
    function downloadSymbol(){
      if (!currentFont || !currentCharCode){ alert('Please select a font and enter a valid character code before downloading.'); return; }
      if (currentFormat==='svg'){ downloadSVG(); } else { downloadPNG(); }
    }

    function downloadSVG(){
      const size = parseInt(document.getElementById('svgSizeInput').value, 10) || 512;
      const svgMarkup = composeSymbolSVG(size, size, { includeCrosshair: false, useGlyph: true });
      if(!svgMarkup){
        alert('Unable to build SVG for this character. Please ensure the glyph exists in the selected font.');
        return;
      }
      const blob = new Blob([svgMarkup], {type:'image/svg+xml'});
      downloadBlob(blob, `${currentFont.replace(/\s+/g,'_')}_${currentCharCode}.svg`);
    }

    function downloadPNG(){
      const size = parseInt(document.getElementById('sizeInput').value, 10) || 512;
      const svgMarkup = composeSymbolSVG(size, size, { includeCrosshair: false, useGlyph: true });
      if(!svgMarkup){
        alert('Unable to build PNG for this character. Please ensure the glyph exists in the selected font.');
        return;
      }

      const svgBlob = new Blob([svgMarkup], {type:'image/svg+xml'});
      const url = URL.createObjectURL(svgBlob);

      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement('canvas');
        canvas.width = size; canvas.height = size;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0,0,size,size);
        ctx.drawImage(img, 0, 0);
        canvas.toBlob(b => {
          downloadBlob(b, `${currentFont.replace(/\s+/g,'_')}_${currentCharCode}.png`);
          URL.revokeObjectURL(url);
        });
      };
      img.onerror = () => {
        URL.revokeObjectURL(url);
        alert('Unable to rasterise the symbol SVG. Please try again.');
      };
      img.src = url;
    }

    function downloadBlob(blob, filename){
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
    }

    /* ---------- Font loading ---------- */
    async function loadFontFiles(event){
      const files = event.target.files;
      if(!files || files.length===0){ reconstructLoadingBanner(installedFonts.length); return; }
      const loadingBanner = document.getElementById('loadingBanner');
      loadingBanner.innerHTML = `
        <div class="header-button-row">
          <button class="load-font-btn">Loading ${files.length} files...</button>
          <button class="copy-path-btn" onclick="copyFontPath()"><span class="copy-path-btn-text">Copy ArcGIS Font path if needed</span></button>
        </div>
        <div id="loadStatus" class="load-status-bar">Please wait...</div>
      `;
      let successCount = 0; const newFonts=[];
      for(const file of files){
        try{
          const arrayBuffer = await file.arrayBuffer();
          const fontName = file.name.replace(/\.(ttf|otf)$/i,'');
          if(installedFonts.includes(fontName) && loadedFontFiles[fontName]){ successCount++; continue; }
          const opentypeFont = opentype.parse(arrayBuffer);
          const fontFace = new FontFace(fontName, arrayBuffer);
          await fontFace.load(); document.fonts.add(fontFace);
          loadedFontFiles[fontName] = {data:arrayBuffer,fileName:file.name,fontFace};
          loadedOpentypeFonts[fontName] = opentypeFont;
          newFonts.push(fontName); successCount++;
        }catch(e){ console.error('Failed to load', file.name, e); }
      }
      installedFonts = [...new Set([...installedFonts, ...newFonts])].sort();
      reconstructLoadingBanner(installedFonts.length);
      document.getElementById('fontCount').textContent = `(${installedFonts.length} available)`;
      populateFontDropdown('');
    }
    function loadArcGISFonts(){ fontFileInput.click(); }

    /* ---------- Init ---------- */
    window.addEventListener('load', ()=>{
      reconstructLoadingBanner(0);
      fontFileInput.addEventListener('change', loadFontFiles);
      colorTargetSymbolBtn.addEventListener('click', ()=>setColorTarget('symbol'));
      colorTargetBgBtn.addEventListener('click', ()=>setColorTarget('background'));
      colorTargetBorderBtn.addEventListener('click', ()=>setColorTarget('border'));
      colorInput.addEventListener('input', ()=>{
        const val = colorInput.value;
        if(colorTarget==='symbol'){ symbolColor = val; }
        else if(colorTarget==='background'){ bgColor = val; }
        else if(colorTarget==='border'){ bgBorderColor = val; }
        renderPreview();
      });

      bgBorderToggleBtn.addEventListener('click', ()=>{ setBorderEnabled(!bgBorderEnabled); });
      borderWidthInput.addEventListener('input', ()=>{
        let width = parseInt(borderWidthInput.value,10);
        if(!Number.isFinite(width)){ width = bgBorderWidth; }
        width = Math.max(1, Math.min(200, width));
        bgBorderWidth = width;
        borderWidthInput.value = bgBorderWidth;
        if(bgBorderEnabled){ renderPreview(); }
      });

      // BG size unit + slider
      document.getElementById('unitPercent').addEventListener('click', ()=>{
        bgSizeUnit='%'; unitPercentBtn.classList.add('active'); unitPixelsBtn.classList.remove('active');
        bgSizeSlider.min=10; bgSizeSlider.max=95; if(bgSizeValue>95){ bgSizeValue=60; } bgSizeSlider.value=bgSizeValue; updateBgSizeLabel(); renderPreview();
      });
      document.getElementById('unitPixels').addEventListener('click', ()=>{
        bgSizeUnit='px'; unitPixelsBtn.classList.add('active'); unitPercentBtn.classList.remove('active');
        bgSizeSlider.min=16; bgSizeSlider.max=1024; if(bgSizeValue<16){ bgSizeValue=200; } bgSizeSlider.value=bgSizeValue; updateBgSizeLabel(); renderPreview();
      });
      bgSizeSlider.addEventListener('input', ()=>{ bgSizeValue=parseInt(bgSizeSlider.value,10); updateBgSizeLabel(); renderPreview(); });
      function updateBgSizeLabel(){ bgSizeLabel.textContent = (bgSizeUnit==='%'? '%: ':'px: ') + bgSizeValue; }

      // BG shape
      bgShapeCircleBtn.addEventListener('click', ()=>toggleBackgroundShape('circle'));
      bgShapeSquareBtn.addEventListener('click', ()=>toggleBackgroundShape('square'));

      syncBackgroundUI();
      setColorTarget('symbol');
      updateKeyboardLabels();
      updateOffsetsUI();
      renderPreview();
      updateDownloadAvailability();
    });
  </script>
</body>
</html>
