  <script>
    /* ---------- State ---------- */
    let installedFonts = [];
    let loadedFontFiles = {};
    let loadedOpentypeFonts = {};
    let currentFormat = 'svg';
    let currentCharCode = null;
    let currentFont = null;

    // Colors
    let symbolColor = '#000000';
    let bgColor = '#ffffff';
    let colorTarget = 'symbol';

    // Background render options
    let bgShape = 'circle';
    let bgSizeUnit = '%';
    let bgSizeValue = 60;

    // Independent offsets
    let bgOffsetX = 0, bgOffsetY = 0;
    let symbolOffsetX = 0, symbolOffsetY = 0;
    const dpadStep = 5;

    // DOM refs
    const fontSearch = document.getElementById('fontSearch');
    const fontDropdown = document.getElementById('fontDropdown');
    const fontSelect = document.getElementById('fontSelect');
    const clearFontBtn = document.getElementById('clearFontBtn');
    const fontFileInput = document.getElementById('fontFileInput');
    const colorInput = document.getElementById('colorInput');
    const colorTargetSymbolBtn = document.getElementById('colorTargetSymbol');
    const colorTargetBgBtn = document.getElementById('colorTargetBackground');
    const previewHost = document.getElementById('previewCanvasHost');
    const previewHint = document.getElementById('previewHint');
    const bgShapeCircleBtn = document.getElementById('bgShapeCircle');
    const bgShapeSquareBtn = document.getElementById('bgShapeSquare');
    const bgSizeSlider = document.getElementById('bgSizeSlider');
    const unitPercentBtn = document.getElementById('unitPercent');
    const unitPixelsBtn = document.getElementById('unitPixels');
    const bgSizeLabel = document.getElementById('bgSizeLabel');
    const offsetReadout = document.getElementById('offsetReadout');
    const symOffsetReadout = document.getElementById('symOffsetReadout');

    /* ---------- Loader banner ---------- */
    function reconstructLoadingBanner(totalFontCount=0){
      const loadingBanner = document.getElementById('loadingBanner');
      const statusMessage = totalFontCount>0 ? `✓ ${totalFontCount} ArcGIS Fonts loaded and ready to use.` : '';
      loadingBanner.innerHTML = `
        <div class="header-button-row">
          <button class="load-font-btn" onclick="loadArcGISFonts()">Load ArcGIS Fonts</button>
          <button class="copy-path-btn" onclick="copyFontPath()"><span class="copy-path-btn-text">Copy ArcGIS Font path if needed</span></button>
        </div>
        <div id="loadStatus" class="load-status-bar">${statusMessage}</div>
      `;
    }

    function copyFontPath(){
      // Windows Explorer–friendly path
      const path = 'C:\\Program Files\\ArcGIS\\Pro\\Resources\\Fonts';
      const btn = event.target.closest('.copy-path-btn');
      navigator.clipboard.writeText(path).then(()=>{
        const span = btn.querySelector('.copy-path-btn-text');
        const original = 'Copy ArcGIS Font path if needed';
        span.textContent = 'Path Copied!';
        btn.classList.add('copied');
        btn.classList.remove('glowing'); void btn.offsetWidth; btn.classList.add('glowing');
        setTimeout(()=>{ span.textContent = original; btn.classList.remove('copied') },2000);
        setTimeout(()=>{ btn.classList.remove('glowing') },800);
      }).catch(()=>{
        const span = btn.querySelector('.copy-path-btn-text');
        const original = 'Copy ArcGIS Font path if needed';
        span.textContent = 'Failed!'; btn.style.backgroundColor = '#e53e3e';
        setTimeout(()=>{ span.textContent = original; btn.style.backgroundColor='' },2000);
      });
    }

    /* ---------- Font selection ---------- */
    function populateFontDropdown(filterText=''){
      const filtered = installedFonts.filter(f=>f.toLowerCase().includes(filterText.toLowerCase()));
      if (filtered.length===0){
        fontDropdown.innerHTML = '<div class="no-results">No fonts loaded. Please load font files.</div>';
      } else {
        fontDropdown.innerHTML = filtered.map(font=>`<div class="font-option" data-font="${font}">${font}</div>`).join('');
        document.querySelectorAll('.font-option').forEach(el=>{
          el.addEventListener('click',()=>selectFont(el.dataset.font));
        });
      }
    }

    function selectFont(fontName){
      fontSearch.value = fontName;
      fontSelect.value = fontName;
      currentFont = fontName;
      fontDropdown.style.display = 'none';
      clearFontBtn.style.display = 'block';
      renderPreview();
    }

    function clearFontSelection(){
      fontSearch.value=''; fontSelect.value=''; currentFont=null;
      clearFontBtn.style.display='none'; populateFontDropdown(''); fontDropdown.style.display='block'; fontSearch.focus();
    }

    fontSearch.addEventListener('focus', function(){ populateFontDropdown(this.value); fontDropdown.style.display='block';});
    fontSearch.addEventListener('input', function(){ populateFontDropdown(this.value); fontDropdown.style.display='block'; if (this.value && fontSelect.value){ clearFontBtn.style.display='block';}});
    document.addEventListener('click', e=>{ if(!e.target.closest('.input-group')) fontDropdown.style.display='none'; });

    /* ---------- Format toggle ---------- */
    document.querySelectorAll('.toggle-btn[data-format]').forEach(btn=>{
      btn.addEventListener('click', function(){
        document.querySelectorAll('.toggle-btn[data-format]').forEach(b=>b.classList.remove('active'));
        this.classList.add('active');
        currentFormat = this.dataset.format;
        const svgInput = document.getElementById('svgSizeInput');
        const pngInput = document.getElementById('sizeInput');
        const sizeLabel = document.getElementById('sizeLabel');
        if (currentFormat==='png'){ pngInput.style.display='block'; svgInput.style.display='none'; sizeLabel.textContent='PNG Size (pixels)'; }
        else { pngInput.style.display='none'; svgInput.style.display='block'; sizeLabel.textContent='SVG Size (pixels)'; }
      });
    });

    /* ---------- Inputs & Keyboard ---------- */
    const keyInput = document.getElementById('keyInput');
    const decimalInput = document.getElementById('decimalInput');
    const hexInput = document.getElementById('hexInput');
    const keyboard = document.getElementById('onscreenKeyboard');
    let isShifted = false;

    // Sync three inputs both ways
    keyInput.addEventListener('input', ()=>{
      const v = keyInput.value;
      if(!v){ decimalInput.value=''; hexInput.value=''; renderPreview(); return; }
      let code;
      if (v.toLowerCase()==='space') code = 32;
      else if (v.toUpperCase().startsWith('U+') && v.length>2) code = parseInt(v.substring(2),16);
      else code = v.codePointAt(0);
      if(Number.isFinite(code)){
        decimalInput.value = code;
        hexInput.value = code.toString(16).toUpperCase().padStart(4,'0');
      }
      renderPreview();
    });
    decimalInput.addEventListener('input', ()=>{
      const d = parseInt(decimalInput.value,10);
      if(Number.isFinite(d)){
        keyInput.value = (d===32) ? 'Space' : String.fromCodePoint(d);
        hexInput.value = d.toString(16).toUpperCase().padStart(4,'0');
      } else { hexInput.value=''; keyInput.value=''; }
      renderPreview();
    });
    hexInput.addEventListener('input', ()=>{
      const h = parseInt(hexInput.value,16);
      if(Number.isFinite(h)){
        decimalInput.value = h;
        keyInput.value = (h===32) ? 'Space' : String.fromCodePoint(h);
      } else { decimalInput.value=''; keyInput.value=''; }
      renderPreview();
    });

    function updateKeyboardLabels(){
      keyboard.querySelectorAll('.key-btn').forEach(btn=>{
        const main = btn.getAttribute('data-main');
        const sh = btn.getAttribute('data-shift');
        if(main){ btn.textContent = isShifted ? (sh || main) : main; }
        else {
          const ch = btn.getAttribute('data-char');
          if(ch==='backspace') btn.textContent = '⌫ Backspace';
          if(ch==='tab') btn.textContent = 'Tab';
          if(ch==='enter') btn.textContent = 'Enter ⏎';
          if(ch==='Shift') btn.textContent = '⇧ Shift';
          if(ch==='ctrl') btn.textContent = 'Ctrl';
          if(ch==='alt') btn.textContent = 'Alt';
          if(ch==='Space') btn.textContent = 'Space';
        }
      });
    }

    if (keyboard){
      keyboard.addEventListener('click', function(e){
        const btn = e.target.closest('.key-btn'); if(!btn) return;
        const charType = btn.dataset.char;
        if(charType==='Shift'){
          isShifted=!isShifted;
          document.querySelectorAll('.key-btn[data-char="Shift"]').forEach(s=>s.classList.toggle('active',isShifted));
          updateKeyboardLabels();
          return;
        }
        if(charType==='backspace'){ keyInput.value=''; keyInput.dispatchEvent(new Event('input')); return; }
        if(charType==='Space'){ keyInput.value='Space'; keyInput.dispatchEvent(new Event('input')); if(isShifted){ isShifted=false; document.querySelectorAll('.key-btn[data-char="Shift"]').forEach(s=>s.classList.remove('active')); updateKeyboardLabels(); } return; }

        const main = btn.getAttribute('data-main');
        const sh = btn.getAttribute('data-shift');
        if(main){
          let ch = isShifted ? (sh || main) : main;
          if(ch.length===1 && /[a-z]/i.test(main)){
            ch = isShifted ? ch.toUpperCase() : ch.toLowerCase();
          }
          keyInput.value = ch;
          keyInput.dispatchEvent(new Event('input'));
          if(isShifted){
            isShifted=false;
            document.querySelectorAll('.key-btn[data-char="Shift"]').forEach(s=>s.classList.remove('active'));
            updateKeyboardLabels();
          }
        }
      });
    }
    document.getElementById('oskLabel')?.addEventListener('click', ()=>{
      document.getElementById('onscreenKeyboardContainer').classList.toggle('expanded');
    });

    /* ---------- Preview Rendering (SVG in host) ---------- */
    function escapeXml(s){ return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

    function renderPreview(){
      const charVal = decimalInput.value ? String.fromCodePoint(parseInt(decimalInput.value,10)) : '';
      if(!currentFont || !charVal){
        previewHost.innerHTML='';
        previewHint.style.display='block';
        return;
      }
      previewHint.style.display='none';

      const hostW = previewHost.clientWidth || 520;
      const hostH = previewHost.clientHeight || 288;

      const topPad = 24;
      const baseSpan = Math.min(hostW, hostH - topPad);

      const trueCx = Math.round(hostW/2);
      const trueCy = Math.round(hostH/2);

      const bgCx = trueCx + bgOffsetX;
      const bgCy = Math.round(topPad + baseSpan * 0.25) + bgOffsetY;

      const symCx = trueCx + symbolOffsetX;
      const symCy = Math.round(topPad + baseSpan * 0.25) + symbolOffsetY;

      const bgPx = (bgSizeUnit==='%') ? Math.max(8, Math.round(baseSpan * (bgSizeValue/100)))
                                       : Math.max(8, Math.round(bgSizeValue));
      const symbolPx = Math.round(baseSpan * 0.35);

      const crosshair = `
        <line x1="0" y1="${trueCy}" x2="${hostW}" y2="${trueCy}" stroke="#a0aec0" stroke-width="1" stroke-dasharray="4 4" opacity="0.6"/>
        <line x1="${trueCx}" y1="0" x2="${trueCx}" y2="${hostH}" stroke="#a0aec0" stroke-width="1" stroke-dasharray="4 4" opacity="0.6"/>
      `;

      const bgNode = bgShape==='circle'
        ? `<circle cx="${bgCx}" cy="${bgCy}" r="${Math.round(bgPx/2)}" fill="${bgColor}"/>`
        : `<rect x="${Math.round(bgCx - bgPx/2)}" y="${Math.round(bgCy - bgPx/2)}" width="${bgPx}" height="${bgPx}" rx="${Math.round(bgPx*0.1)}" fill="${bgColor}"/>`;

      const svg = `
        <svg width="${hostW}" height="${hostH}" viewBox="0 0 ${hostW} ${hostH}" xmlns="http://www.w3.org/2000/svg">
          ${crosshair}
          ${bgNode}
          <text
            x="${symCx}" y="${symCy}"
            fill="${symbolColor}"
            font-family="${currentFont}, sans-serif"
            font-size="${symbolPx}"
            text-anchor="middle"
            dominant-baseline="central"
          >${escapeXml(charVal)}</text>
        </svg>
      `;
      previewHost.innerHTML = svg;
    }

    /* ---------- D-pads & Centre buttons ---------- */
    document.getElementById('dpadUp').addEventListener('click', ()=>{ bgOffsetY -= dpadStep; updateOffsetsUI(); renderPreview(); });
    document.getElementById('dpadDown').addEventListener('click', ()=>{ bgOffsetY += dpadStep; updateOffsetsUI(); renderPreview(); });
    document.getElementById('dpadLeft').addEventListener('click', ()=>{ bgOffsetX -= dpadStep; updateOffsetsUI(); renderPreview(); });
    document.getElementById('dpadRight').addEventListener('click', ()=>{ bgOffsetX += dpadStep; updateOffsetsUI(); renderPreview(); });
    document.getElementById('dpadCenter').addEventListener('click', ()=>{ bgOffsetX=0; bgOffsetY=0; updateOffsetsUI(); renderPreview(); });

    document.getElementById('symDpadUp').addEventListener('click', ()=>{ symbolOffsetY -= dpadStep; updateOffsetsUI(); renderPreview(); });
    document.getElementById('symDpadDown').addEventListener('click', ()=>{ symbolOffsetY += dpadStep; updateOffsetsUI(); renderPreview(); });
    document.getElementById('symDpadLeft').addEventListener('click', ()=>{ symbolOffsetX -= dpadStep; updateOffsetsUI(); renderPreview(); });
    document.getElementById('symDpadRight').addEventListener('click', ()=>{ symbolOffsetX += dpadStep; updateOffsetsUI(); renderPreview(); });
    document.getElementById('symDpadCenter').addEventListener('click', ()=>{ symbolOffsetX=0; symbolOffsetY=0; updateOffsetsUI(); renderPreview(); });

    function getCanvasMetrics() {
      const hostW = previewHost.clientWidth || 520;
      const hostH = previewHost.clientHeight || 288;
      const topPad = 24;
      const baseSpan = Math.min(hostW, hostH - topPad);
      const trueCx = Math.round(hostW / 2);
      const targetCyLine = Math.round(topPad + baseSpan * 0.25);
      return { hostW, hostH, topPad, baseSpan, trueCx, targetCyLine };
    }

    document.getElementById('dpadCenterToCanvas')?.addEventListener('click', () => {
      const { targetCyLine } = getCanvasMetrics();
      const trueCy = Math.round((previewHost.clientHeight || 288) / 2);
      bgOffsetX = 0;
      bgOffsetY = trueCy - targetCyLine;
      updateOffsetsUI();
      renderPreview();
    });

    document.getElementById('symCenterToCanvas')?.addEventListener('click', () => {
      const { targetCyLine } = getCanvasMetrics();
      const trueCy = Math.round((previewHost.clientHeight || 288) / 2);
      symbolOffsetX = 0;
      symbolOffsetY = trueCy - targetCyLine;
      updateOffsetsUI();
      renderPreview();
    });

    function updateOffsetsUI(){
      offsetReadout.textContent = `${bgOffsetX}, ${bgOffsetY}`;
      symOffsetReadout.textContent = `${symbolOffsetX}, ${symbolOffsetY}`;
    }

    /* ---------- Generate Preview (alerts retained) ---------- */
    function generatePreview(){
      const selectedFont = fontSelect.value;
      const decimalCode = parseInt(decimalInput.value);
      if(!selectedFont){ alert('Please select a font'); return; }
      if(Number.isNaN(decimalCode)){ alert('Please enter a valid character code'); return; }
      currentFont = selectedFont; currentCharCode = decimalCode;
      renderPreview();
      document.getElementById('downloadBtn').disabled=false;
    }

    /* ---------- Downloads (crosshair excluded; SVG fixed no-mirroring) ---------- */
    function downloadSymbol(){
      if (!currentFont || !currentCharCode){ alert('Please generate a preview first'); return; }
      if (currentFormat==='svg'){ downloadSVG(); } else { downloadPNG(); }
    }

    // More accurate SVG export using glyph paths (no mirroring; excludes crosshair)
    function downloadSVG(){
      const size = parseInt(document.getElementById('svgSizeInput').value) || 512;
      const font = loadedOpentypeFonts[currentFont];
      if(!font){ alert('Error: Font data not found. Please reload the font.'); return; }

      const character = String.fromCodePoint(currentCharCode);
      const glyph = font.charToGlyph(character);
      if(!glyph || glyph.index===0){ alert('Character not found in font. Glyph index: '+(glyph?.index)); return; }

      const topPad = Math.round(size*0.08);
      const baseSpan = size - topPad;
      const trueCx = Math.round(size/2);

      const bgCxExp = trueCx + bgOffsetX;
      const bgCyExp = Math.round(topPad + baseSpan*0.25) + bgOffsetY;
      const bgPxExp = (bgSizeUnit==='%') ? Math.max(8, Math.round(size * (bgSizeValue/100)))
                                         : Math.max(8, Math.min(size, Math.round(bgSizeValue)));

      const bgNode = (bgShape==='circle')
        ? `<circle cx="${bgCxExp}" cy="${bgCyExp}" r="${Math.round(bgPxExp/2)}" fill="${bgColor}"/>`
        : `<rect x="${Math.round(bgCxExp - bgPxExp/2)}" y="${Math.round(bgCyExp - bgPxExp/2)}" width="${bgPxExp}" height="${bgPxExp}" rx="${Math.round(bgPxExp*0.1)}" fill="${bgColor}"/>`;

      const symCxExp = trueCx + symbolOffsetX;
      const symCyExp = Math.round(topPad + baseSpan*0.25) + symbolOffsetY;

      const fontSize = Math.round(size * 0.35);
      const scale = fontSize / font.unitsPerEm;
      const path = glyph.getPath(0,0,fontSize);
      const pathData = path.toPathData(2);
      const bounds = glyph.getBoundingBox();
      const glyphW = (bounds.x2-bounds.x1)*scale;
      const glyphH = (bounds.y2-bounds.y1)*scale;

      // Center glyph at (symCxExp, symCyExp); flip Y with scale(1,-1)
      const x = (symCxExp - glyphW/2) - (bounds.x1*scale);
      const y = (symCyExp + glyphH/2) - ((bounds.y2)*scale);

      const svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" xmlns="http://www.w3.org/2000/svg">
  ${bgNode}
  <g transform="translate(${x.toFixed(2)}, ${y.toFixed(2)}) scale(1, -1)">
    <path d="${pathData}" fill="${symbolColor}"/>
  </g>
</svg>`;
      const blob = new Blob([svg], {type:'image/svg+xml'});
      downloadBlob(blob, `${currentFont.replace(/\s+/g,'_')}_${currentCharCode}.svg`);
    }

    // Simple PNG export: draw generated SVG onto canvas (excludes crosshair by design)
    function downloadPNG(){
      const size = parseInt(document.getElementById('sizeInput').value) || 512;

      // Build an export SVG (without crosshair), then rasterize to PNG
      const topPad = Math.round(size*0.08);
      const baseSpan = size - topPad;
      const trueCx = Math.round(size/2);

      const bgCxExp = trueCx + bgOffsetX;
      const bgCyExp = Math.round(topPad + baseSpan*0.25) + bgOffsetY;
      const bgPxExp = (bgSizeUnit==='%') ? Math.max(8, Math.round(size * (bgSizeValue/100)))
                                         : Math.max(8, Math.min(size, Math.round(bgSizeValue)));

      const bgNode = (bgShape==='circle')
        ? `<circle cx="${bgCxExp}" cy="${bgCyExp}" r="${Math.round(bgPxExp/2)}" fill="${bgColor}"/>`
        : `<rect x="${Math.round(bgCxExp - bgPxExp/2)}" y="${Math.round(bgCyExp - bgPxExp/2)}" width="${bgPxExp}" height="${bgPxExp}" rx="${Math.round(bgPxExp*0.1)}" fill="${bgColor}"/>`;

      const symCxExp = trueCx + symbolOffsetX;
      const symCyExp = Math.round(topPad + baseSpan*0.25) + symbolOffsetY;

      const charVal = String.fromCodePoint(currentCharCode);
      const svgExport = `
        <svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
          ${bgNode}
          <text x="${symCxExp}" y="${symCyExp}" fill="${symbolColor}"
                font-family="${currentFont}, sans-serif"
                font-size="${Math.round(size*0.35)}"
                text-anchor="middle" dominant-baseline="central">${charVal.replace(/&/g,'&amp;')}</text>
        </svg>
      `.trim();

      const svgBlob = new Blob([svgExport], {type:'image/svg+xml'});
      const url = URL.createObjectURL(svgBlob);

      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement('canvas');
        canvas.width = size; canvas.height = size;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0,0,size,size);
        ctx.drawImage(img, 0, 0);
        canvas.toBlob(b => {
          downloadBlob(b, `${currentFont.replace(/\s+/g,'_')}_${currentCharCode}.png`);
          URL.revokeObjectURL(url);
        });
      };
      img.src = url;
    }

    function downloadBlob(blob, filename){
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
    }

    /* ---------- Font loading ---------- */
    async function loadFontFiles(event){
      const files = event.target.files;
      if(!files || files.length===0){ reconstructLoadingBanner(installedFonts.length); return; }
      const loadingBanner = document.getElementById('loadingBanner');
      loadingBanner.innerHTML = `
        <div class="header-button-row">
          <button class="load-font-btn">Loading ${files.length} files...</button>
          <button class="copy-path-btn" onclick="copyFontPath()"><span class="copy-path-btn-text">Copy ArcGIS Font path if needed</span></button>
        </div>
        <div id="loadStatus" class="load-status-bar">Please wait...</div>
      `;
      let successCount = 0; const newFonts=[];
      for(const file of files){
        try{
          const arrayBuffer = await file.arrayBuffer();
          const fontName = file.name.replace(/\.(ttf|otf)$/i,'');
          if(installedFonts.includes(fontName) && loadedFontFiles[fontName]){ successCount++; continue; }
          const opentypeFont = opentype.parse(arrayBuffer);
          const fontFace = new FontFace(fontName, arrayBuffer);
          await fontFace.load(); document.fonts.add(fontFace);
          loadedFontFiles[fontName] = {data:arrayBuffer,fileName:file.name,fontFace};
          loadedOpentypeFonts[fontName] = opentypeFont;
          newFonts.push(fontName); successCount++;
        }catch(e){ console.error('Failed to load', file.name, e); }
      }
      installedFonts = [...new Set([...installedFonts, ...newFonts])].sort();
      reconstructLoadingBanner(installedFonts.length);
      document.getElementById('fontCount').textContent = `(${installedFonts.length} available)`;
      populateFontDropdown('');
    }
    function loadArcGISFonts(){ fontFileInput.click(); }

    /* ---------- Init ---------- */
    window.addEventListener('load', ()=>{
      reconstructLoadingBanner(0);
      fontFileInput.addEventListener('change', loadFontFiles);
      document.getElementById('colorTargetSymbol').addEventListener('click', ()=>{ colorTarget='symbol'; colorTargetSymbolBtn.classList.add('active'); colorTargetBgBtn.classList.remove('active'); colorInput.value=symbolColor; });
      document.getElementById('colorTargetBackground').addEventListener('click', ()=>{ colorTarget='background'; colorTargetBgBtn.classList.add('active'); colorTargetSymbolBtn.classList.remove('active'); colorInput.value=bgColor; });
      colorInput.addEventListener('input', ()=>{ if(colorTarget==='symbol'){ symbolColor=colorInput.value; } else { bgColor=colorInput.value; } renderPreview(); });

      // BG size unit + slider
      document.getElementById('unitPercent').addEventListener('click', ()=>{
        bgSizeUnit='%'; unitPercentBtn.classList.add('active'); unitPixelsBtn.classList.remove('active');
        bgSizeSlider.min=10; bgSizeSlider.max=95; if(bgSizeValue>95){ bgSizeValue=60; } bgSizeSlider.value=bgSizeValue; updateBgSizeLabel(); renderPreview();
      });
      document.getElementById('unitPixels').addEventListener('click', ()=>{
        bgSizeUnit='px'; unitPixelsBtn.classList.add('active'); unitPercentBtn.classList.remove('active');
        bgSizeSlider.min=16; bgSizeSlider.max=1024; if(bgSizeValue<16){ bgSizeValue=200; } bgSizeSlider.value=bgSizeValue; updateBgSizeLabel(); renderPreview();
      });
      bgSizeSlider.addEventListener('input', ()=>{ bgSizeValue=parseInt(bgSizeSlider.value,10); updateBgSizeLabel(); renderPreview(); });
      function updateBgSizeLabel(){ bgSizeLabel.textContent = (bgSizeUnit==='%'? '%: ':'px: ') + bgSizeValue; }

      // BG shape
      bgShapeCircleBtn.addEventListener('click', ()=>{ bgShape='circle'; bgShapeCircleBtn.classList.add('active'); bgShapeSquareBtn.classList.remove('active'); renderPreview(); });
      bgShapeSquareBtn.addEventListener('click', ()=>{ bgShape='square'; bgShapeSquareBtn.classList.add('active'); bgShapeCircleBtn.classList.remove('active'); renderPreview(); });

      updateKeyboardLabels();
      updateOffsetsUI();
      renderPreview();
    });
  </script>
</body>
</html>
